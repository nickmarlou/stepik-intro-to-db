# Администрирование MySQL и оптимизация запросов

## План выполнения запроса

> **План выполнения запроса** - описание того, какие отношения и как будут использоваться для выполнения запроса

План выполнения запроса показывает для каждого этапа:
* количество задействованных кортежей
* использование ключей: фактические и возможные

Стратегия составления плана:
1. С какой таблицы начать? СУБД выбирает ту, где меньше кортежей
2. Условия сортируются так, что первыми выполняются условия, отсеивающие наибольшее количество кортежей
3. Какие ключи использовать, чтобы как можно раньше и как можно больше отфильтровать

Чтобы посмотреть план запроса, перед ним нужно добавить ключевое слово `explain`.

```sql
explain
SELECT * FROM sale_has_good
JOIN sale ON sale.id=sale_has_good.sale_id
JOIN good ON good.id=sale_has_good.good_id;
```

Полученный план запроса используется для:
* проверки порядка выполнения операций в запросе для последующей оптимизации
* проверки используемых индексов
* определения количества кортежей, которые будут обработаны во время выполнения запроса

## Индексы

Как хранятся данные?
* Для быстрого поиска данные хранятся в упорядоченном виде ([бинарный поиск](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA))
* Чтобы изменять упорядоченные данные можно использовать дерево

> Индекс - объект базы данных, создаваемый с целью повышения производительности поиска данных. Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, [сбалансированного дерева](https://ru.wikipedia.org/wiki/%D0%90%D0%92%D0%9B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) ([Википедия](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)))

Существует два типа индексов: кластерные и некластерные.

При наличии **кластерного индекса** строки таблицы упорядочены по значению ключа этого индекса. Если в таблице нет кластерного индекса, таблица называется кучей.

**Некластерный индекс**, созданный для такой таблицы, содержит только указатели на записи таблицы. Кластерный индекс может быть только одним для каждой таблицы, но каждая таблица может иметь несколько различных некластерных индексов, каждый из которых определяет свой собственный порядок следования записей.

Последовательность, в которой столбцы представлены в **составном индексе**, достаточно важна. Дело в том, что получить набор данных по запросу, затрагивающему только первый из проиндексированных столбцов, можно. Однако в большинстве СУБД невозможно или неэффективно получение данных только по второму и далее проиндексированным столбцам (без ограничений на первый столбец).

> Индексы могут быть реализованы различными структурами. Наиболее часто употребимы [B*-деревья](https://ru.wikipedia.org/wiki/B*-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE), [B+-деревья](https://ru.wikipedia.org/wiki/B%2B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE), [B-деревья](https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) и хеши.

Информация о хэшировании и хэш-таблицах:
* [Алгоритмы. Структуры данных. Хеш-таблицы](https://www.youtube.com/watch?v=E6oY2EcMi9Y)
* [CS50 Hash tables](https://www.youtube.com/watch?v=nvzVHwrrub0)
* [Информатика. Структуры данных: Хеширование и хеш-функция](https://www.youtube.com/watch?v=BtBxtoXBI54)
* [What is a HashTable Data Structure - Introduction to Hash Tables , Part 0](https://www.youtube.com/watch?v=MfhjkfocRR0)

## Создание индексов

[explain join types](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types)