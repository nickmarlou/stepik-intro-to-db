# 2. Основы реляционных баз данных

## 2.1 Введение в реляционную модель данных

Модель данных

* Структурная часть
* Операционная часть
* Ограничения целостности

### РМД. Структурная часть

* Тип данных

    * Все элементы в РМД строго тимпизированы
    * Основные типы

        * Целочисленные (INT, BIGINT, SMALLINT)
        * Данные с дробной частью (NUMERIC/DECIMAL, FLOAT)
        * Строковые (CHAR, VARCHAR, STRING)
        * Календарные (DATE, TIME, DATETIME, TIMESTAMP)
        * Другие (XML, JSON)
        * NULL (явное указание на то, что значения нет)

* Домен

    * Подмножество множества значений определенного типа данных
    * Логическое выражение над определенным базовым типом данных, которое добавляет к нему дополнительные органичения. Например, для целочисленного базового типа данных можно ввести органичение на ввод отрицательных чисел

* Атрибут

    * Именованная характеристика - свойство сущности
    * Определяется на типе данных или домене

* Кортеж

    * Множество упорядоченных триплетов: имя данных, тип атрибута или домен, значение

* Схема отношения, схема БД

    * Схема отношения - именованное множество упорядоченных пар: имя атрибута, тип данных или домен. Название схема отношений - название таблицы
    * Схема БД - множество именованных схем отношения, связанных друг с другом

    * Отношение — фундаментальное понятие реляционной модели данных. По этой причине модель и называется реляционной. Отношение состоит из заголовка и тела. **Пусть дана совокупность типов данных T1, T2, ..., Tn, называемых также доменами, & не обязательно различных. Тогда n-арным отношением R, или отношением R степени n > называют подмножество декартовa произведения множеств T1, T2, ..., Tn.**
        * Тело отношения - множество кортежей, соотвествующих схеме отношения.
        * Заголовок (схема) отношения - конечное множество упорядоченных пар вида (Ai, Ti), где Ai — имя атрибута, а Ti — имя типа (домена), i=1,…, n.
        * Основные свойства отношения

            * В отношении нет двух одинаковых элементов (кортежей)
            * Порядок кортежей в отношении не определён
            * Порядок атрибутов в заголовке отношения не определён

Пусть заданы следующие типы (домены):

* T1 = {Иванов, Петров, Сидоров}
* T2 = {Физика, Химия}
* T3 = {3, 4, 5}

Тогда декартово произведение T1 * T2 * T3 состоит из 18 кортежей, где каждый кортеж содержит три значения: первое — одна из фамилий, второе — учебная дисциплина, а третье — оценка.

Пусть отношение R имеет заголовок H: { (Фамилия, T1), (Дисциплина, T2), (Оценка, T3)}.

Тогда тело отношения R может моделировать реальную ситуацию и содержать пять кортежей, которые соответствуют результатам сессии (Петров экзамен по Физике не сдавал). Отобразим отношение в виде таблицы:

|Фамилия|Дисциплина|Оценка|
|-------|----------|------|
|Иванов|Физика|4|
|Иванов|Химия|3|
|Петров|Химия|5|
|Сидоров|Физика|5|
|Сидоров|Химия|4|

> Отношение обычно имеет простую графическую интерпретацию в виде таблицы, столбцы которой соответствуют атрибутам, а строки — кортежам, а в «ячейках» находятся значения атрибутов в кортежах. Тем не менее, в строгой реляционной модели отношение не является таблицей, кортеж — это не строка, а атрибут — это не столбец. Термины «таблица», «строка», «столбец» могут использоваться только в неформальном контексте.>

* Механизмы

    * Реляционная алгебра
    * Реляционные исчисления

* Ограничение целостности

    * Целостность сущности

        * Кортежи должны быть отличимы
        * Должен быть потенциальный ключ, т.е. подмножество множества атрибутов отношения, набор значений которого является уникальным для любого кортежа
            * Уникальность
            * Минимальность (из подмножества уже нельзя исключить атрибуты, не нарушив уникальность)
        * Виды ключей по количеству атрибутов
            * Простые (1 атрибут)
            * Составные (несколько атрибутов)

    * Целостность ссылок

        * **Внешний ключ**

            * Специальный атрибут отношения такой, что значения данного атрибута в некотором отношении R2 будут соответсвовать значениям атрибутов первичного ключа некоторого отношения R1. R1 - главное отношение, R2 - подчиненное отношение.


## 2.3 Выборки из нескольких источников

Оператор SELECT возвращает результат соединения, если обращается к нескольким источникам данных.

Результат соединения - нестрого подмножество декартова произведения результатов выборок из нескольких источников.

Виды соединений:

* CROSS JOIN
* INNER JOIN
* LEFT OUTER JOIN, RIGHT OUTER JOIN
* FULL OUTER JOIN
* NATURAL JOIN

### CROSS JOIN

```sql
# В качестве результата соединения возвращается декартово произведение

SELECT * FROM product, category;
SELECT * FROM product CROSS JOIN category;
```

### Тета-соединение или внутреннее соединение (INNER JOIN, NATURAL JOIN)

```sql
# В качестве результата соединения возвращается подмножество кортежей из декартова произведения, которое удовлетворяем определенному условию (равеноство атрибута category_id)

SELECT * FROM product
    INNER JOIN category ON product.category_id = category.category_id;

# Можно указать наименования атрибутов, которые должны присутствовать вовращаемых в кортежах. Если наименования атрибутов уникальны, название таблицы можно не добавлять.

SELECT product.product_name, product.price, category.category_name FROM product
	INNER JOIN category ON product.category_id = category.category_id;
```

### Левое и правое внешние соединения (LEFT OUTER JOIN, RIGHT OUTER JOIN)

Результат левого (правого) внешнего соединения содержит кортежи из внутреннего соединения источников и не вошедшие во внутреннее соединение кортежи левого (правого) источника.

Атрибуты, которые не имеют совпадений по общим столбцам заполняются неопределенными значениями.

Если по указанному атрибуту нет совпадений, для *LEFT OUTER JOIN* отсутствующие значения из правой таблицы заполняются *null*. Для *RIGHT OUTER JOIN* - наоборот.

```sql
# Пример левого внешнего соединения

USE store_medium;

SELECT * FROM category as c LEFT OUTER JOIN product as p on p.category_id = c.category_id;
```

### Объединение (UNION)

```sql
# Пример объединения двух множеств
USE store_medium;

SELECT * FROM product where price < 100
union
SELECT * FROM product where price > 900;
```

## 2.4 Триггеры и хранимые процедуры

### Хранимые процедуры

> Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз и хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML).

Преимущества:
* Производительность
* Организация поддержки целостности
* Скрытие структуры данных
* Модульность
* Безопасность
* Использование общего кода при работе с БД нескольких приложений

[Хранимые процедуры в MySQL](https://dev.mysql.com/doc/refman/5.6/en/stored-programs-defining.html)

```sql
# Пример для MySQL

# Переопределяем стандартный разделитель
delimiter |
# Удаляем процедуру, если она уже создана
DROP PROCEDURE IF EXISTS get_orders_by_status|
# Создаём процедуру, принимающую строковые параметр не более 20 символов
CREATE PROCEDURE get_orders_by_status(status VARCHAR(20))
# Обозначаем начало тела процедуры с помощью BEGIN
BEGIN
    SELECT
        s.number
        FROM sale as s
        INNER JOIN status as st
        ON s.status_id=st.id
        WHERE st.name=status;
# Обозначаем конец тела процедуры с помощью END
END|
# Снова устанавливаем стандартный разделитель
delimiter ;
# Вызываем процедуру
CALL get_orders_by_status('new');

```

### Триггеры

> Триггер — хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением INSERT, удалением DELETE строки в заданной таблице, или изменением UPDATE данных в определённом столбце заданной таблицы реляционной базы данных.

Вызов триггера возможен до операции или после нее.

* Варианты использования

    * Проверка данных
    * Поддержка согласованности
    * Журналирование и аудит
    * Запуск процедур не связанных с обработкой данных

* Недостатки

    * Непрозрачность
    * Сложность отладки
    * Производительность
    * Глобальность

```sql
# Пример для MySQL

# Переопределяем стандартный разделитель
delimiter |

# Создаем триггер
CREATE TRIGGER on_update_order
    AFTER UPDATE
    ON `order` FOR EACH ROW
BEGIN
    # `NEW` позволяет использовать новые данные (после UPDATE)
    CALL update_order_history(NEW.id, NEW.status_id, NEW.sum);
END
|
```